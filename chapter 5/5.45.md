## exercise 5.45

### a)

Compile to run [the code of factorial](./eceval-compiler-example.scm), typing in sequence

``` Scheme
(factorial 1)   ; (total-pushes = 7 maximum-depth = 3)
(factorial 2)   ; (total-pushes = 13 maximum-depth = 5)
(factorial 3)   ; (total-pushes = 19 maximum-depth = 8)
(factorial 4)   ; (total-pushes = 25 maximum-depth = 11)
(factorial 5)   ; (total-pushes = 31 maximum-depth = 14)
(factorial 6)   ; (total-pushes = 37 maximum-depth = 17)
(factorial 7)   ; (total-pushes = 43 maximum-depth = 20)
(factorial 8)   ; (total-pushes = 49 maximum-depth = 23)
(factorial 9)   ; (total-pushes = 55 maximum-depth = 26)
(factorial 10)  ; (total-pushes = 61 maximum-depth = 29)
```

Make a table

|  n            | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 |
|-------------- |----|----|----|----|----|----|----|----|----|----|
| total-pushes  | 7  | 13 | 19 | 25 | 31 | 37 | 43 | 49 | 55 | 61 |
| maximum-depth | 3  | 5  | 8  | 11 | 14 | 17 | 20 | 23 | 26 | 29 |

By observation, we know.When n >= 2, `total-pushes` and `maximum-depth` are arithmetic sequences

```
total-pushes = 13 + (n - 2) * 6 = 6 * n + 1
maximum-depth = 5 + (n - 2) * 3 = 3 * n - 1
```

Compare the interpreter version in [exercise 5.27](./5.27.md). As n becomes larger, the constant term can be ignored, and the ratio of compiler to interpreter is:

```
total-pushes: (6 * n + 1) / (32 * n - 16) => 6/32 = 0.1875
maximum-depth: (3 * n - 1) / (5 * n + 3) => 3/5 = 0.6
```

Compare the hand-built factorial machine in [exercise 5.14](./5.14.md). As n increases, the ratio of compiler to dedicated machine is:

```
total-pushes: (6 * n + 1) / (2 * n - 2) => 6/2 = 3
maximum-depth: (3 * n - 1) / (2 * n - 2) => 3/2 = 1.5
```

From the above comparison, we can see that the hand-built specialized machine is superior to the compiler version, and the compiler version is superior to the interpreter version.

### b)

Keep the code generated by the compiler close to the manual version.You can start with the open code at [exercise 5.38](./5.38.scm). This assumes that '+ * - =' are all fundamental functions.

After the open code is applied, the compiled generated factorial code is at the end, with a stack utilization of
```
total-pushes = 2 * n + 3
maximum-depth = 2 * n - 2
```

It's getting a little bit closer to hand-crafted code.There are two other major differences

1. The handmade code, `n` and `factorial` are stored directly in registers.Compile the generated code, put the two data into the environment `env`, and there is a process to find the environment.
2. Handmade code, the recursive call to `factorial` is a direct jump.To compile the generated code, there is a procedure to find `factorial`, called explicitly.

We can modify the compiler based on the above two points.

1. Improve the compiler's use of registers.Put data in registers first, not in the environment.
2. When compiling a recursive call, jump directly to the entry.Avoid procedures that explicitly look up the environment and then invoke it.


``` Scheme
'((assign val (op make-compiled-procedure) (label entry1) (reg env))
  (goto (label after-lambda2))
  entry1
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
  (assign arg1 (op lookup-variable-value) (const n) (reg env))
  (assign arg2 (const 1))
  (assign val (op =) (reg arg1) (reg arg2))
  (test (op false?) (reg val))
  (branch (label false-branch4))
  true-branch3
  (assign val (const 1))
  (goto (reg continue))
  false-branch4
  (save continue)
  (save env)
  (assign proc (op lookup-variable-value) (const factorial) (reg env))
  (assign arg1 (op lookup-variable-value) (const n) (reg env))
  (assign arg2 (const 1))
  (assign val (op -) (reg arg1) (reg arg2))
  (assign argl (op list) (reg val))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch6))
  compiled-branch7
  (assign continue (label proc-return9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  proc-return9
  (assign arg1 (reg val))
  (goto (label after-call8))
  primitive-branch6
  (assign arg1 (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call8
  (restore env)
  (restore continue)
  (assign arg2 (op lookup-variable-value) (const n) (reg env))
  (assign val (op *) (reg arg1) (reg arg2))
  (goto (reg continue))
  after-if5
  after-lambda2
  (perform (op define-variable!) (const factorial) (reg val) (reg env))
  (assign val (const ok)))
```
